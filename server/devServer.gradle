import com.google.appengine.task.RunTask
import org.activityinfo.store.mysql.MySqlDatabase


ext {
    configFile = project.file("$buildDir/config.properties")
}

// Generate the server's configuration on-the-fly based on this build's properties
def writeConfiguration(MySqlDatabase database) {
    Properties config = new Properties()
    config.setProperty("hibernate.connection.pool_size", "0")
    config.setProperty("hibernate.connection.driver_class", "com.mysql.jdbc.Driver")
    config.setProperty("hibernate.connection.username", database.server.username)
    config.setProperty("hibernate.connection.password", database.server.password)
    config.setProperty("hibernate.connection.url", database.url)
    
    // Point to the postmark stub service
    config.setProperty("postmark.url", "http://localhost:${postmarkStubPort}/email")
    config.setProperty("postmark.key", "POSTMARK_API_TEST")

    configFile.withOutputStream { OutputStream out ->
        config.store(out, "Acceptance Test Configuration")
    }
}

def healthCheck() {
    // Verify that the server actually started
    try {
        URL url = new URL("http://localhost:${devServerPort}/login")
        def connection = url.openConnection() as HttpURLConnection

        println("DevServer started successfully: ${connection.responseCode}")

    } catch(IOException e) {
        throw new RuntimeException("AppEngine DevServer failed to start: ${e.message}", e)
    }
}

task appengineExplodeDevMode(type: Copy) {
    group = "Google App Engine"
    description = "Creates a partial, exploded web app layout for GWT Dev Mode"
    
    // In order to run (super)dev mode, we need ONLY the part of the
    // web app required for the server side, which includes
    // compiled Java classes, resources, and server-side libraries
    
    dependsOn compileJava
    from("$projectDir/src/main/webapp")
    from(configurations.runtime) {
        into "WEB-INF/lib"
    }
    from(sourceSets.main.output) {
        into "WEB-INF/classes"
    }
    into "$buildDir/explodedDevMode"
}


task appengineDevMode(type: JavaExec) {
    dependsOn appengineDownloadSdk
    dependsOn appengineExplodeDevMode
    dependsOn compileJava
    dependsOn project(':ui:app').tasks.getByName("compileJava")
    dependsOn project(':ui:app2').tasks.getByName("compileJava")
    dependsOn project(':ui:theme').tasks.getByName("compileJava")


    main = 'com.google.gwt.dev.DevMode'


    classpath project(":ui:app2").configurations.gwtSdk

    // Java sources first, so that changes get picked up on refresh
    def sourceProjects = [":ui:app", ":ui:app2", ":ui:theme", ":i18n", ":clients:gwtrest", ":tools:json", ":model"];
    for(sourceProject in sourceProjects) {
        classpath project(sourceProject).sourceSets.main.java.srcDirs
        classpath project(sourceProject).sourceSets.main.resources.srcDirs
    }

    classpath project(':ui:app').sourceSets.main.runtimeClasspath
    classpath project(':ui:app2').sourceSets.main.runtimeClasspath

    // APT Generated sources
    classpath project(':ui:app').sourceSets.main.output.generatedSourcesDir

    for(sourceProject in sourceProjects) {
        classpath project(sourceProject).sourceSets.main.runtimeClasspath
    }


    // Server classes
    classpath sourceSets.main.runtimeClasspath

    args '-logLevel', 'WARN'
    args '-server', 'com.google.appengine.tools.development.gwt.AppEngineLauncher'
    args '-war', "${buildDir}/explodedDevMode"
    args '-startupUrl', 'login'
    args '-port', devServerPort
    args 'org.activityinfo.ui.ActivityInfoDevMode'
    args 'org.activityinfo.ui.AppDev'

    doFirst {
        // The SDK root is only available after appengineDownloadSdk runs
        def sdkRoot = System.getProperty('appengine.sdk.root')
        classpath "${sdkRoot}/lib/appengine-tools-api.jar"

        // The appengine agent is a runtime agent that makes sure
        // we don't use any classes that are forbidden in the AppEngine environment.
        // However, it doesn't seem to have been updated for the new Java8 runtime.
        //
        // We can't remove the agent entirely, because the AppEngineLauncher class
        // will throw an error if it is not on the classpath. So, as a workaround,
        // place it on the classpath, but don't install it as an agent.

        classpath "${sdkRoot}/lib/agent/appengine-agent.jar"

        // Write the application configuration pointing to the development database
        writeConfiguration mysql.localDev
        jvmArgs "-Dactivityinfo.config=${configFile}"
        jvmArgs "-Xdebug"
        jvmArgs "-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000"
        jvmArgs "-verbose:class"
        for(File classpathEntry : classpath) {
            logger.lifecycle("Classpath: " + classpathEntry)
        }

    }
}


appengineRun {
    ext.database = mysql.localDev
    
    // Bind to all address so that we can test ODK from the local network
    // For example, http://192.168.1.1
    httpAddress = "0.0.0.0"
}

task appengineStartAT(type: RunTask) {
    group = "Google App Engine"
    description = "Starts a local AppEngine Development Server for Acceptance Testing in the background"

    dependsOn 'appengineExplodeApp', 'setupDatabaseAT'

    daemon = true
    ext.database = mysql.localAT
}

task appengineRunAT(type: RunTask) {
    group = "Google App Engine"
    description = "Runs a local AppEngine Development Server for Acceptance Testing"

    dependsOn 'appengineExplodeApp', 'setupDatabaseAT', 'classes', 'compileGwt'
    ext.database = mysql.localAT
}

tasks.withType(RunTask) {

    // Provide a configuration for the server
    jvmFlags += ["-Dactivityinfo.config=${configFile}", '-Xdebug', '-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000']

    doFirst {
        writeConfiguration ext.database
    }
    
    doLast {
        if(daemon) {
            // Make sure the server successfully started
            healthCheck()    
        }
    }
}